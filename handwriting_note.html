<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>手書きノート</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-20px); }
    }
    
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    @keyframes glow {
      0%, 100% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.5); }
      50% { box-shadow: 0 0 40px rgba(102, 126, 234, 0.8), 0 0 60px rgba(118, 75, 162, 0.6); }
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      background: linear-gradient(-45deg, #1a1a2e, #16213e, #0f3460, #533483);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(102, 126, 234, 0.1) 1px, transparent 1px);
      background-size: 50px 50px;
      animation: float 20s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }
    
    #app { 
      max-width: 1400px; 
      margin: 0 auto; 
      padding: 20px; 
      position: relative;
      z-index: 1;
      animation: fadeInUp 0.6s ease-out;
    }
    
    .header {
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(20px);
      padding: 25px;
      border-radius: 20px;
      margin-bottom: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                  0 0 60px rgba(102, 126, 234, 0.2);
      border: 1px solid rgba(102, 126, 234, 0.2);
      animation: fadeInUp 0.6s ease-out 0.1s both;
    }
    
    .header h1 {
      font-size: 28px;
      margin-bottom: 20px;
      color: #fff;
      text-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
      animation: pulse 3s ease-in-out infinite;
    }
    
    .toolbar {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .tool-group {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      border: 1px solid rgba(102, 126, 234, 0.2);
      transition: all 0.3s ease;
    }
    
    .tool-group:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(102, 126, 234, 0.4);
      transform: translateY(-2px);
    }
    
    .btn {
      padding: 12px 18px;
      border: 1px solid rgba(102, 126, 234, 0.3);
      border-radius: 10px;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
      font-size: 14px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(102, 126, 234, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .btn:hover::before {
      width: 300px;
      height: 300px;
    }
    
    .btn:hover { 
      background: rgba(102, 126, 234, 0.2);
      transform: translateY(-3px);
      box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4);
      border-color: rgba(102, 126, 234, 0.6);
    }
    
    .btn span { position: relative; z-index: 1; }
    .btn.active { 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-color: transparent;
      animation: glow 2s ease-in-out infinite;
      box-shadow: 0 0 30px rgba(102, 126, 234, 0.6),
                  0 8px 25px rgba(0, 0, 0, 0.3);
    }
    
    .color-picker { display: flex; gap: 10px; }
    .color-btn {
      width: 40px; height: 40px; border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.2);
      cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); position: relative;
    }
    .color-btn::after {
      content: ''; position: absolute; top: -5px; left: -5px; right: -5px; bottom: -5px;
      border-radius: 50%; border: 2px solid transparent; transition: all 0.3s ease;
    }
    .color-btn:hover { transform: scale(1.2) rotate(10deg); box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4); }
    .color-btn.active::after { border-color: #fff; animation: pulse 1.5s ease-in-out infinite; }
    
    .slider-group { display: flex; align-items: center; gap: 12px; }
    .slider-group label { font-size: 14px; color: rgba(255, 255, 255, 0.8); white-space: nowrap; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
    input[type="range"] {
      width: 120px; cursor: pointer; height: 6px;
      background: rgba(255, 255, 255, 0.1); border-radius: 3px; outline: none;
      border: 1px solid rgba(102, 126, 234, 0.3); transition: all 0.3s ease;
    }
    input[type="range"]:hover { background: rgba(255, 255, 255, 0.15); border-color: rgba(102, 126, 234, 0.5); }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none; width: 20px; height: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 50%; cursor: pointer;
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.8); transition: all 0.3s ease;
    }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 0 30px rgba(102, 126, 234, 1); }
    .value-display { min-width: 35px; text-align: center; font-weight: bold; color: #fff; text-shadow: 0 0 10px rgba(102, 126, 234, 0.8); }
    
    .tabs-container {
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(20px);
      padding: 20px; border-radius: 20px; margin-bottom: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                  0 0 60px rgba(102, 126, 234, 0.2);
      border: 1px solid rgba(102, 126, 234, 0.2);
      animation: fadeInUp 0.6s ease-out 0.2s both;
    }
    .tabs { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 10px; }
    .tabs::-webkit-scrollbar { height: 8px; }
    .tabs::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 4px; }
    .tabs::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 4px; box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
    }
    .tab {
      padding: 14px 28px; background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(102, 126, 234, 0.3);
      border-radius: 12px; cursor: pointer; white-space: nowrap;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 14px; display: flex; align-items: center; gap: 10px;
      color: rgba(255, 255, 255, 0.8); position: relative; overflow: hidden;
    }
    .tab::before {
      content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
      transition: left 0.5s;
    }
    .tab:hover::before { left: 100%; }
    .tab:hover { background: rgba(102, 126, 234, 0.2); transform: translateY(-3px);
      box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4); border-color: rgba(102, 126, 234, 0.6); color: #fff; }
    .tab.active { 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-color: transparent;
      animation: glow 2s ease-in-out infinite; box-shadow: 0 0 30px rgba(102, 126, 234, 0.6), 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    .tab-close { margin-left: 8px; opacity: 0.7; transition: all 0.3s ease; font-size: 18px; }
    .tab-close:hover { opacity: 1; transform: scale(1.3) rotate(90deg); color: #ff4757; }
    
    .canvas-container {
      background: #fff; border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 80px rgba(102, 126, 234, 0.3);
      overflow: hidden; position: relative; border: 1px solid rgba(102, 126, 234, 0.3);
      animation: fadeInUp 0.6s ease-out 0.3s both;
    }
    
    canvas { display: block; touch-action: none; }
    canvas.pen { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="black"/></svg>') 10 10, crosshair; }
    canvas.eraser { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><rect x="5" y="5" width="10" height="10" fill="white" stroke="black"/></svg>') 10 10, crosshair; }
    canvas.line, canvas.rect, canvas.circle, canvas.arrow { cursor: crosshair; }
    canvas.text { cursor: text; }
    canvas.select { cursor: move; }
    
    .action-buttons { display: flex; gap: 10px; }
    .undo-redo { display: flex; gap: 6px; }
    .separator { 
      width: 2px; height: 40px; 
      background: linear-gradient(to bottom, transparent, rgba(102, 126, 234, 0.5), transparent);
      margin: 0 8px; box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
    }
    
    .zoom-control {
      display: flex; align-items: center; gap: 10px;
      background: rgba(255, 255, 255, 0.05); padding: 10px 16px; border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); border: 1px solid rgba(102, 126, 234, 0.3);
      transition: all 0.3s ease;
    }
    .zoom-control:hover { background: rgba(255, 255, 255, 0.08); border-color: rgba(102, 126, 234, 0.5); }
    .zoom-control button {
      width: 36px; height: 36px; border: 1px solid rgba(102, 126, 234, 0.3);
      background: rgba(102, 126, 234, 0.1); border-radius: 8px; cursor: pointer;
      font-size: 20px; font-weight: bold; color: #fff; transition: all 0.3s ease;
    }
    .zoom-control button:hover {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); transform: scale(1.1);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
    }
    .zoom-value { min-width: 55px; text-align: center; font-weight: bold; font-size: 14px; color: #fff; text-shadow: 0 0 10px rgba(102, 126, 234, 0.8); }
    
    .text-input-overlay { position: absolute; display: none; }
    .text-input-overlay.active { display: block; animation: fadeInUp 0.3s ease-out; }
    .text-input-overlay input {
      border: 2px solid #667eea; padding: 12px; font-size: 16px; border-radius: 8px;
      background: rgba(26, 26, 46, 0.95); color: #fff;
      box-shadow: 0 0 40px rgba(102, 126, 234, 0.6), 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    .text-input-overlay input::placeholder { color: rgba(255, 255, 255, 0.5); }
    .text-input-overlay input:focus {
      outline: none; border-color: #764ba2;
      box-shadow: 0 0 60px rgba(102, 126, 234, 0.8), 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    @media (max-width: 768px) {
      .tool-group { width: 100%; justify-content: center; }
      .header h1 { font-size: 22px; }
      .btn { padding: 10px 14px; font-size: 13px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="header">
      <h1>📝 手書きノート</h1>
      <div class="toolbar">
        <div class="tool-group">
          <button class="btn active" onclick="setTool('pen', this)" title="ペン">
            <span>✏️</span><span>ペン</span>
          </button>
          <button class="btn" onclick="setTool('highlighter', this)" title="蛍光ペン">
            <span>🖍️</span><span>蛍光</span>
          </button>
          <button class="btn" onclick="setTool('eraser', this)" title="消しゴム">
            <span>🧹</span><span>消しゴム</span>
          </button>
        </div>
        
        <div class="separator"></div>
        
        <div class="tool-group">
          <button class="btn" onclick="setTool('line', this)" title="直線">
            <span>📏</span><span>直線</span>
          </button>
          <button class="btn" onclick="setTool('arrow', this)" title="矢印">
            <span>➡️</span><span>矢印</span>
          </button>
          <button class="btn" onclick="setTool('rect', this)" title="四角形">
            <span>▢</span><span>四角</span>
          </button>
          <button class="btn" onclick="setTool('circle', this)" title="円">
            <span>○</span><span>円</span>
          </button>
          <button class="btn" onclick="setTool('text', this)" title="テキスト">
            <span>T</span><span>文字</span>
          </button>
        </div>
        
        <div class="separator"></div>
        
        <div class="tool-group color-picker">
          <div class="color-btn active" style="background:#000" onclick="setColor('#000', this)" title="黒"></div>
          <div class="color-btn" style="background:#ff0000" onclick="setColor('#ff0000', this)" title="赤"></div>
          <div class="color-btn" style="background:#0066ff" onclick="setColor('#0066ff', this)" title="青"></div>
          <div class="color-btn" style="background:#00cc00" onclick="setColor('#00cc00', this)" title="緑"></div>
          <div class="color-btn" style="background:#ffcc00" onclick="setColor('#ffcc00', this)" title="黄"></div>
          <div class="color-btn" style="background:#ff00ff" onclick="setColor('#ff00ff', this)" title="紫"></div>
          <div class="color-btn" style="background:#ff8800" onclick="setColor('#ff8800', this)" title="橙"></div>
        </div>
        
        <div class="separator"></div>
        
        <div class="tool-group slider-group">
          <label>太さ:</label>
          <input type="range" min="1" max="30" value="3" oninput="setWidth(this.value)">
          <span class="value-display" id="widthValue">3</span>
        </div>
        
        <div class="separator"></div>
        
        <div class="tool-group slider-group">
          <label>透明度:</label>
          <input type="range" min="10" max="100" value="100" oninput="setOpacity(this.value)">
          <span class="value-display" id="opacityValue">100</span>
        </div>
        
        <div class="separator"></div>
        
        <div class="tool-group action-buttons">
          <div class="undo-redo">
            <button class="btn" onclick="undo()" title="元に戻す">↶</button>
            <button class="btn" onclick="redo()" title="やり直し">↷</button>
          </div>
          <button class="btn" onclick="clearCanvas()" title="クリア">🗑️ クリア</button>
          <button class="btn" onclick="downloadCanvas()" title="ダウンロード">💾 保存</button>
        </div>
        
        <div class="separator"></div>
        
        <div class="zoom-control">
          <button onclick="zoomOut()">−</button>
          <span class="zoom-value" id="zoomValue">100%</span>
          <button onclick="zoomIn()">+</button>
        </div>
      </div>
    </div>
    
    <div class="tabs-container">
      <div class="tabs" id="tabs"></div>
      <button class="btn" onclick="addPage()" style="margin-top: 15px;">
        <span>+</span><span>新しいページ</span>
      </button>
    </div>
    
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      <div class="text-input-overlay" id="textInput">
        <input type="text" placeholder="テキストを入力...">
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let pages = [{ strokes: [], history: [], historyStep: -1 }];
    let currentPage = 0;
    let drawing = false;
    let tool = 'pen';
    let color = '#000';
    let lineWidth = 3;
    let opacity = 1;
    let startX, startY;
    let snapshot;
    let zoom = 1;
    let currentStroke = null;

    // 安全なリサイズ
    function resizeCanvas() {
      if (!canvas.parentElement || !canvas.parentElement.isConnected) return;
      const container = canvas.parentElement;

      const w = Math.max(1, container.clientWidth || 0);
      const h = Math.max(600, (window.innerHeight || 0) - 300);
      if (w === 0 || h === 0) return;

      const prevW = canvas.width || 0;
      const prevH = canvas.height || 0;

      let tempCanvas = null, tempCtx = null;
      if (prevW > 0 && prevH > 0) {
        tempCanvas = document.createElement('canvas');
        tempCanvas.width = prevW;
        tempCanvas.height = prevH;
        tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(canvas, 0, 0);
      }

      canvas.width = w;
      canvas.height = h;

      if (tempCanvas) ctx.drawImage(tempCanvas, 0, 0);

      redraw();
    }

    // 初期化は DOM 構築後
    window.addEventListener('DOMContentLoaded', () => {
      resizeCanvas();
      updateTabs();
      saveHistory();

      // マウス
      canvas.addEventListener('mousedown', startDraw);
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseup', endDraw);
      canvas.addEventListener('mouseout', endDraw);

      // タッチ（preventDefault を効かせるため passive:false）
      canvas.addEventListener('touchstart', startDraw, { passive: false });
      canvas.addEventListener('touchmove', draw, { passive: false });
      canvas.addEventListener('touchend', endDraw, { passive: false });
    });

    window.addEventListener('resize', resizeCanvas);
    
    function setTool(t, el) {
      tool = t;
      canvas.className = t;
      document.querySelectorAll('.toolbar .btn').forEach(b => b.classList.remove('active'));
      if (el) el.classList.add('active');
    }
    
    function setColor(c, el) {
      color = c;
      document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
      if (el) el.classList.add('active');
    }
    
    function setWidth(w) {
      lineWidth = Number(w);
      document.getElementById('widthValue').textContent = w;
    }
    
    function setOpacity(o) {
      opacity = Number(o) / 100;
      document.getElementById('opacityValue').textContent = o;
    }
    
    function clearCanvas() {
      if (confirm('このページをクリアしますか？')) {
        saveHistory();
        pages[currentPage].strokes = [];
        redraw();
      }
    }
    
    function addPage() {
      pages.push({ strokes: [], history: [], historyStep: -1 });
      currentPage = pages.length - 1;
      updateTabs();
      redraw();
    }
    
    function switchPage(idx) {
      if (idx < 0 || idx >= pages.length) return;
      currentPage = idx;
      updateTabs();
      redraw();
    }
    
    function deletePage(idx, e) {
      e.stopPropagation();
      if (pages.length === 1) {
        alert('最後のページは削除できません');
        return;
      }
      if (confirm(`ページ ${idx + 1} を削除しますか？`)) {
        pages.splice(idx, 1);
        if (currentPage >= pages.length) currentPage = pages.length - 1;
        updateTabs();
        redraw();
      }
    }
    
    function updateTabs() {
      const tabsEl = document.getElementById('tabs');
      tabsEl.innerHTML = pages.map((_, i) => 
        `<button class="tab ${i === currentPage ? 'active' : ''}" onclick="switchPage(${i})">
          📄 ページ ${i + 1}
          ${pages.length > 1 ? `<span class="tab-close" onclick="deletePage(${i}, event)">×</span>` : ''}</button>`
      ).join('');
    }
    
    function saveHistory() {
      const page = pages[currentPage];
      page.history = page.history.slice(0, page.historyStep + 1);
      page.history.push(JSON.parse(JSON.stringify(page.strokes)));
      page.historyStep++;
      if (page.history.length > 50) {
        page.history.shift();
        page.historyStep--;
      }
    }
    
    function undo() {
      const page = pages[currentPage];
      if (page.historyStep > 0) {
        page.historyStep--;
        page.strokes = JSON.parse(JSON.stringify(page.history[page.historyStep]));
        redraw();
      }
    }
    
    function redo() {
      const page = pages[currentPage];
      if (page.historyStep < page.history.length - 1) {
        page.historyStep++;
        page.strokes = JSON.parse(JSON.stringify(page.history[page.historyStep]));
        redraw();
      }
    }
    
    function zoomIn() {
      zoom = Math.min(zoom + 0.1, 3);
      updateZoom();
    }
    
    function zoomOut() {
      zoom = Math.max(zoom - 0.1, 0.5);
      updateZoom();
    }
    
    function updateZoom() {
      document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';
      redraw();
    }
    
    function downloadCanvas() {
      const link = document.createElement('a');
      link.download = `note_page${currentPage + 1}_${Date.now()}.png`;
      link.href = canvas.toDataURL();
      link.click();
    }
    
    function redraw() {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.scale(zoom, zoom);
      
      const strokes = pages[currentPage].strokes;
      for (const stroke of strokes) {
        ctx.globalAlpha = stroke.opacity;
        ctx.strokeStyle = stroke.color;
        ctx.fillStyle = stroke.color;
        ctx.lineWidth = stroke.width;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        if (stroke.type === 'path') {
          if (!stroke.points || stroke.points.length === 0) continue;
          ctx.beginPath();
          ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
          stroke.points.forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
        } else if (stroke.type === 'line') {
          ctx.beginPath();
          ctx.moveTo(stroke.x1, stroke.y1);
          ctx.lineTo(stroke.x2, stroke.y2);
          ctx.stroke();
        } else if (stroke.type === 'arrow') {
          drawArrow(stroke.x1, stroke.y1, stroke.x2, stroke.y2);
        } else if (stroke.type === 'rect') {
          if (stroke.filled) {
            ctx.fillRect(stroke.x, stroke.y, stroke.w, stroke.h);
          } else {
            ctx.strokeRect(stroke.x, stroke.y, stroke.w, stroke.h);
          }
        } else if (stroke.type === 'circle') {
          ctx.beginPath();
          ctx.arc(stroke.x, stroke.y, stroke.r, 0, Math.PI * 2);
          if (stroke.filled) ctx.fill(); else ctx.stroke();
        } else if (stroke.type === 'text') {
          ctx.font = `${stroke.size}px sans-serif`;
          ctx.fillText(stroke.text, stroke.x, stroke.y);
        }
      }
      
      ctx.restore();
    }
    
    function drawArrow(x1, y1, x2, y2) {
      const angle = Math.atan2(y2 - y1, x2 - x1);
      const headlen = 15;
      
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
      ctx.stroke();
    }
    
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const touch = (e.touches && e.touches[0]) || (e.changedTouches && e.changedTouches[0]) || e;
      return {
        x: (touch.clientX - rect.left) / zoom,
        y: (touch.clientY - rect.top) / zoom
      };
    }
    
    function startDraw(e) {
      if (e.cancelable) e.preventDefault();
      const pos = getPos(e);
      startX = pos.x;
      startY = pos.y;
      
      if (tool === 'text') {
        const rect = canvas.getBoundingClientRect();
        const touch = (e.touches && e.touches[0]) || (e.changedTouches && e.changedTouches[0]) || e;
        const textInputDiv = document.getElementById('textInput');
        const textInput = textInputDiv.querySelector('input');
        textInputDiv.style.left = (touch.clientX - rect.left) + 'px';
        textInputDiv.style.top  = (touch.clientY - rect.top) + 'px';
        textInputDiv.classList.add('active');
        textInput.value = '';
        textInput.focus();
        
        textInput.onkeydown = (ke) => {
          if (ke.key === 'Enter') {
            if (textInput.value.trim()) {
              saveHistory();
              pages[currentPage].strokes.push({
                type: 'text',
                text: textInput.value,
                x: pos.x,
                y: pos.y,
                color: color,
                opacity: opacity,
                size: lineWidth * 5
              });
              redraw();
            }
            textInputDiv.classList.remove('active');
          } else if (ke.key === 'Escape') {
            textInputDiv.classList.remove('active');
          }
        };
        return;
      }
      
      drawing = true;
      saveHistory();
      
      if (tool === 'pen' || tool === 'eraser' || tool === 'highlighter') {
        currentStroke = {
          type: 'path',
          points: [pos],
          color: tool === 'eraser' ? '#fff' : color,
          width: tool === 'eraser' ? lineWidth * 2 : lineWidth,
          opacity: tool === 'highlighter' ? 0.3 : (tool === 'eraser' ? 1 : opacity)
        };
        pages[currentPage].strokes.push(currentStroke);
      } else {
        // いまの描画内容をスナップショット
        snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }
    }
    
    function draw(e) {
      if (!drawing) return;
      if (e.cancelable) e.preventDefault();
      
      const pos = getPos(e);
      
      if (tool === 'pen' || tool === 'eraser' || tool === 'highlighter') {
        currentStroke.points.push(pos);
        redraw();
      } else {
        // プレビュー
        ctx.putImageData(snapshot, 0, 0);
        ctx.save();
        ctx.scale(zoom, zoom);
        ctx.globalAlpha = opacity;
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.lineCap = 'round';
        
        if (tool === 'line') {
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();
        } else if (tool === 'arrow') {
          drawArrow(startX, startY, pos.x, pos.y);
        } else if (tool === 'rect') {
          ctx.strokeRect(startX, startY, pos.x - startX, pos.y - startY);
        } else if (tool === 'circle') {
          const r = Math.hypot(pos.x - startX, pos.y - startY);
          ctx.beginPath();
          ctx.arc(startX, startY, r, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    
    function endDraw(e) {
      if (!drawing) return;
      drawing = false;
      
      const pos = getPos(e);
      
      if (tool === 'line') {
        pages[currentPage].strokes.push({
          type: 'line',
          x1: startX, y1: startY,
          x2: pos.x, y2: pos.y,
          color, width: lineWidth, opacity
        });
      } else if (tool === 'arrow') {
        pages[currentPage].strokes.push({
          type: 'arrow',
          x1: startX, y1: startY,
          x2: pos.x, y2: pos.y,
          color, width: lineWidth, opacity
        });
      } else if (tool === 'rect') {
        pages[currentPage].strokes.push({
          type: 'rect',
          x: startX, y: startY,
          w: pos.x - startX, h: pos.y - startY,
          color, width: lineWidth, opacity
        });
      } else if (tool === 'circle') {
        const r = Math.hypot(pos.x - startX, pos.y - startY);
        pages[currentPage].strokes.push({
          type: 'circle',
          x: startX, y: startY, r,
          color, width: lineWidth, opacity
        });
      }
      
      redraw();
      currentStroke = null;
    }
  </script>
</body>
</html>
